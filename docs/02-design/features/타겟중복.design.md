# 타겟중복율 — Design

> 최종 갱신: 2026-02-28 (코드 기준 현행화)
> 코드리뷰 7건 반영

## 1. 데이터 모델

### adset_overlap_cache 테이블
```sql
CREATE TABLE adset_overlap_cache (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  account_id text NOT NULL,
  adset_pair text NOT NULL,        -- 정렬된 ID 조합: [a,b].sort().join("_")
  period_start date NOT NULL,
  period_end date NOT NULL,
  overlap_data jsonb NOT NULL,     -- { overlap_rate, reach_a, reach_b, combined_unique }
  cached_at timestamptz DEFAULT now(),
  UNIQUE(account_id, adset_pair, period_start, period_end)
);
ALTER TABLE adset_overlap_cache ENABLE ROW LEVEL SECURITY;
-- service_role만 접근 (API 서버에서 createServiceClient 사용)
```

### adset_pair 규칙
- 항상 두 ID를 오름차순 정렬: `[idA, idB].sort().join("_")`
- 전체 결과 row: `adset_pair = "__overall__"`

### overlap_data jsonb 스키마
**pair별 row**:
```json
{ "overlap_rate": 60.5, "reach_a": 5000, "reach_b": 3000, "combined_unique": 3200,
  "adset_a_name": "...", "adset_b_name": "...", "campaign_a": "...", "campaign_b": "..." }
```
**전체 row** (adset_pair = "__overall__"):
```json
{ "overall_rate": 25.3, "total_unique": 15000, "individual_sum": 20000 }
```

> `daily_overlap_insights` 테이블은 설계되었으나 미구현. API에서 참조하지만 항상 fallback으로 adset_overlap_cache 사용.

## 2. API 설계

### GET /api/protractor/overlap
| 파라미터 | 필수 | 설명 |
|----------|------|------|
| account_id | O | 광고계정 ID |
| date_start | O | 시작일 (YYYY-MM-DD) |
| date_end | O | 종료일 (YYYY-MM-DD) |
| force | X | true면 캐시 무시 |

### 캐시 전략
- TTL: 24시간 (`cached_at > NOW() - INTERVAL '24h'`)
- HIT: DB에서 pair rows + overall row 조회 → 즉시 반환
- MISS 또는 force=true: Meta API 호출 → 계산 → DB upsert → 반환

### Meta API 호출 전략 (rate limit 대응)
1. **캠페인 목록**: `GET act_{id}/campaigns?effective_status=["ACTIVE"]&fields=id,name,objective` → OUTCOME_SALES 필터
2. **광고세트 목록**: 각 캠페인별 `GET {campaign_id}/adsets?effective_status=["ACTIVE"]&fields=id,name`
3. **개별 reach**: `daily_ad_insights` DB에서 `SUM(reach) GROUP BY adset_id` (Meta API 미호출)
4. **조합 overlap**: Meta Insights API — `act_{id}/insights?filtering=[{"field":"adset.id","operator":"IN","value":[A,B]}]&fields=reach&date_preset=...`
5. **전체 unique**: Meta Insights API 1회 — `filtering=[adset.id IN [모두]]`

### 기간 제한
> 설계: 7일 미만 → 400 에러
> 실제: API에 7일 최소 검증 미구현. UI에서 3일 미만 시 경고 배너만 표시 (차단 아님).

### 응답 형식
```json
{
  "overall_rate": 25.3,
  "total_unique": 15000,
  "individual_sum": 20000,
  "cached_at": "2026-02-25T12:00:00Z",
  "pairs": [
    { "adset_a_name": "...", "adset_b_name": "...", "campaign_a": "...", "campaign_b": "...", "overlap_rate": 60.5 }
  ]
}
```

### 에러 처리
| 코드 | 메시지 |
|------|--------|
| 400 | "account_id, date_start, date_end는 필수입니다." |
| 401 | "인증이 필요합니다." |
| 403 | "해당 계정에 대한 접근 권한이 없습니다." |
| 404 | "활성 캠페인이 없습니다." |
| 500/502/503/504 | Meta API 관련 에러 |

## 3. 컴포넌트 구조

### OverlapAnalysis.tsx (src/components/protractor/OverlapAnalysis.tsx)
```
Props: accountId, dateRange, overlapData, isLoading, onRefresh
├── 계정 미선택 안내
├── 3일 미만 경고 배너 (amber, 차단 아님)
├── 로딩 스켈레톤
├── 히어로: 도넛 (recharts PieChart innerRadius) + 수치 3개
│   - 색상: #F75D5D (중복), #E5E7EB (고유)
├── 위험 경고: overlap_rate >= 60% 조합 (빨간 배경)
├── 전체 세트 테이블 (정렬 가능)
│   - 컬럼: 캠페인명, 세트명, Reach, 최고중복, 상태
├── 새로 분석 버튼 (onRefresh)
├── 해석 가이드 (항상 표시, 접기/펼치기 미구현)
└── 마지막 분석 시각 (cached_at)
```

### real-dashboard.tsx 변경
- import: Tabs UI + OverlapAnalysis
- state: activeTab, overlapData, loadingOverlap
- useEffect: overlap fetch (accountId + dateRange 변경 시)
- JSX: 탭 구조 감싸기 (Header+PeriodSelector는 탭 밖)

## 4. 구현 상태
- [x] Plan 문서
- [x] Design 문서
- [x] 마이그레이션 (adset_overlap_cache)
- [x] overlap API route
- [x] OverlapAnalysis 컴포넌트 + dashboard 탭 연결
- [x] 빌드 성공

### 미구현 항목
- [ ] daily_overlap_insights 테이블 (DB에 미생성)
- [ ] API 7일 최소 기간 검증 (현재 기간 제한 없음)
- [ ] 해석 가이드 접기/펼치기 (현재 항상 표시)
