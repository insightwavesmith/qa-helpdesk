<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>P2 리뷰 보고서 — AI 수정 요청 + 비용 로깅</title>
  <style>
    :root { --primary: #F75D5D; --bg: #fff; --text: #1a1a1a; --muted: #6b7280; --border: #e5e7eb; --code-bg: #f3f4f6; --green: #16a34a; --green-bg: #dcfce7; --blue: #2563eb; --blue-bg: #dbeafe; --amber: #d97706; --amber-bg: #fef3c7; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Pretendard', -apple-system, sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; max-width: 960px; margin: 0 auto; padding: 40px 24px; }
    h1 { font-size: 28px; font-weight: 800; margin-bottom: 8px; }
    h2 { font-size: 22px; font-weight: 700; margin-top: 48px; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid var(--primary); }
    h3 { font-size: 17px; font-weight: 700; margin-top: 28px; margin-bottom: 10px; }
    p, li { font-size: 15px; }
    .subtitle { font-size: 14px; color: var(--muted); margin-bottom: 32px; }
    .box { padding: 16px 20px; border-radius: 0 8px 8px 0; margin: 20px 0; font-size: 14px; }
    .blue { background: var(--blue-bg); border-left: 4px solid var(--blue); }
    .amber { background: var(--amber-bg); border-left: 4px solid var(--amber); }
    .green { background: var(--green-bg); border-left: 4px solid var(--green); }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 14px; }
    th, td { padding: 10px 14px; border: 1px solid var(--border); text-align: left; }
    th { background: var(--code-bg); font-weight: 600; }
    code { background: var(--code-bg); padding: 2px 6px; border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; }
    pre { background: var(--code-bg); padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px; line-height: 1.6; margin: 12px 0; }
    pre code { background: none; padding: 0; }
    ul { padding-left: 24px; margin: 8px 0; }
    li { margin: 4px 0; }
  </style>
</head>
<body>

<h1>P2 리뷰 보고서</h1>
<p class="subtitle">AI 수정 요청 + 비용 로깅 | 2026-02-16 | KnowledgeService v3.1 P2 | 리뷰어: 모찌</p>

<h2>1. 요약</h2>

<div class="box blue">
P2는 2건으로 축소됨. T1은 콘텐츠 편집 UX 개선 (AI에게 수정 지시), T2는 운영 모니터링 (토큰 비용 추적).<br>
핵심 로직(knowledge.ts generate 함수) 변경 최소화. 기존 KnowledgeService 인프라를 그대로 활용.
</div>

<table>
  <tr><th>태스크</th><th>유형</th><th>담당</th><th>신규 파일</th><th>수정 파일</th><th>위험도</th></tr>
  <tr><td>T1: AI 수정 요청</td><td>Full-stack</td><td>frontend + backend</td><td>ai-edit-panel.tsx</td><td>content/[id]/page.tsx, contents.ts</td><td>Medium</td></tr>
  <tr><td>T2: KS 비용 로깅</td><td>Backend</td><td>backend-dev</td><td>knowledge_usage.sql</td><td>knowledge.ts</td><td>Low</td></tr>
</table>

<h2>2. T1: AI 수정 요청 — 변경 계획</h2>

<h3>목표</h3>
<p>콘텐츠 상세 페이지에서 Smith님이 "도입부 강하게", "표 추가해" 같은 수정 지시를 입력하면 Opus가 기존 본문을 수정해서 반환. 확인 후 적용.</p>

<h3>호출 흐름</h3>
<pre><code>Smith님: 수정 지시 입력 ("배너키 넣어서 다시 써줘")
    ↓
ai-edit-panel.tsx → reviseContentWithAI() server action
    ↓
contents.ts: 현재 콘텐츠 조회 (body_md 또는 email_summary)
    ↓
knowledge.ts: generate({ query: 현재 텍스트 + 수정 지시, consumerType, systemPromptOverride })
    ↓
Opus 4.6 API → 수정된 텍스트 반환
    ↓
ai-edit-panel.tsx: 미리보기 표시
    ↓
Smith님: "적용하기" 클릭 → updateContent() → DB 저장 → MDXEditor 갱신</code></pre>

<h3>파일별 변경</h3>
<table>
  <tr><th>파일</th><th>변경</th><th>설명</th></tr>
  <tr><td><code>src/components/content/ai-edit-panel.tsx</code></td><td>NEW</td><td>수정 대상 선택(본문/이메일요약) + 수정 지시 textarea + 요청 버튼 + 결과 미리보기 + 적용/재요청 버튼</td></tr>
  <tr><td><code>src/app/(main)/admin/content/[id]/page.tsx</code></td><td>MOD</td><td>정보공유 탭 PostEditPanel 위에 AiEditPanel 컴포넌트 추가</td></tr>
  <tr><td><code>src/actions/contents.ts</code></td><td>MOD</td><td><code>reviseContentWithAI(contentId, target, instruction)</code> server action 추가</td></tr>
</table>

<h3>주요 설계 결정</h3>
<ul>
  <li><strong>DB 저장 안 함</strong>: 수정본은 미리보기만 → "적용하기" 눌러야 저장. 되돌리기 가능.</li>
  <li><strong>KS Consumer 재사용</strong>: 본문은 education, 이메일요약은 newsletter consumer 사용. 기존 RAG 파이프라인 그대로 활용.</li>
  <li><strong>systemPromptOverride</strong>: 수정 전용 시스템 프롬프트 주입. 기존 TYPE_PROMPTS와 별개.</li>
</ul>

<div class="box amber">
<strong>우려 1: RAG 컨텍스트 필요 여부</strong><br>
수정 요청 시 generate()를 호출하면 임베딩→벡터검색→RAG 컨텍스트 주입이 실행됨. 
"도입부 강하게"같은 스타일 수정에는 RAG가 불필요하고 토큰만 낭비됨.<br>
<strong>제안:</strong> RAG 검색 없이 Opus API만 직접 호출하는 경량 함수를 별도로 만들거나, 
limit=0으로 RAG 컨텍스트를 비활성화하는 방법 고려.
</div>

<div class="box amber">
<strong>우려 2: PostEditPanel(MDXEditor) 동기화</strong><br>
"적용하기" 후 updateContent()로 DB 저장은 되지만, PostEditPanel의 MDXEditor 내부 상태가 자동 갱신되는지 확인 필요.<br>
현재 PostEditPanel은 <code>initialBodyMd</code> prop이 바뀌면 useEffect로 에디터 상태를 리셋함 (L80~86).
<code>refreshContent()</code> 호출로 page.tsx의 content state가 갱신되면 → prop 변경 → 에디터 동기화 가능.<br>
<strong>확인 필요:</strong> refreshContent()가 page.tsx에서 content를 re-fetch하는지 검증.
</div>

<h2>3. T2: KS 비용 로깅 — 변경 계획</h2>

<h3>파일별 변경</h3>
<table>
  <tr><th>파일</th><th>변경</th><th>설명</th></tr>
  <tr><td>Supabase SQL</td><td>NEW</td><td><code>knowledge_usage</code> 테이블 + 인덱스 2개</td></tr>
  <tr><td><code>src/lib/knowledge.ts</code></td><td>MOD</td><td>generate() 함수 return 직전에 fire-and-forget INSERT. KnowledgeRequest에 questionId?, contentId? 추가.</td></tr>
</table>

<h3>로깅 삽입 위치</h3>
<pre><code>// knowledge.ts generate() — return 직전
const supabase = createServiceClient();
supabase.from("knowledge_usage").insert({
  consumer_type: request.consumerType,
  input_tokens: data.usage?.input_tokens || 0,
  output_tokens: data.usage?.output_tokens || 0,
  total_tokens: tokensUsed,
  model: MODEL,
  question_id: request.questionId || null,
  content_id: request.contentId || null,
  duration_ms: Date.now() - startTime,
}).then(() => {}).catch(err => console.error("[KS] Usage log failed:", err));

return { content, sourceRefs, tokensUsed, model: MODEL };</code></pre>

<div class="box green">
<strong>안전성 확인</strong><br>
- <code>createServiceClient</code>는 knowledge.ts에 이미 import됨 → 추가 의존성 없음<br>
- fire-and-forget 패턴 → KS 응답 속도에 영향 없음<br>
- KnowledgeRequest에 optional 필드 추가 → 기존 호출부 변경 불필요 (하위 호환)
</div>

<h2>4. 영향 범위</h2>

<h3>신규 파일 (2건)</h3>
<ul>
  <li><code>src/components/content/ai-edit-panel.tsx</code> — AI 수정 요청 UI</li>
  <li>Supabase SQL: <code>knowledge_usage</code> 테이블</li>
</ul>

<h3>수정 파일 (3건)</h3>
<ul>
  <li><code>src/app/(main)/admin/content/[id]/page.tsx</code> — AiEditPanel import + 렌더</li>
  <li><code>src/actions/contents.ts</code> — reviseContentWithAI 액션 추가</li>
  <li><code>src/lib/knowledge.ts</code> — generate() 로깅 + KnowledgeRequest 확장</li>
</ul>

<h3>수정 금지 파일</h3>
<ul>
  <li><code>email-renderer.ts</code>, <code>email-template-utils.ts</code> — 렌더링 로직</li>
  <li><code>gemini.ts</code> — generateEmbedding</li>
  <li><code>knowledge.ts</code> generate() 핵심 흐름 (검색→RAG→생성)</li>
</ul>

<h2>5. 우려 사항 및 제안</h2>

<table>
  <tr><th>#</th><th>이슈</th><th>심각도</th><th>제안</th></tr>
  <tr>
    <td>1</td>
    <td><strong>T1: RAG 컨텍스트 불필요</strong> — 스타일 수정에 임베딩+벡터검색은 낭비</td>
    <td>Medium</td>
    <td><code>limit: 0</code>으로 RAG 스킵하거나, Anthropic API 직접 호출하는 경량 함수 분리</td>
  </tr>
  <tr>
    <td>2</td>
    <td><strong>T1: MDXEditor 동기화</strong> — 적용 후 에디터 내부 상태 갱신 필요</td>
    <td>Low</td>
    <td><code>refreshContent()</code> → content re-fetch → initialBodyMd prop 변경 → useEffect 리셋. 동작 검증 필요.</td>
  </tr>
  <tr>
    <td>3</td>
    <td><strong>T1: 55초 타임아웃</strong> — 5000자+ 본문 수정 시 Opus 응답 지연 가능</td>
    <td>Low</td>
    <td>현재 TIMEOUT_MS 55초. 수정 요청은 RAG 검색 시간 + 생성 시간이므로 충분할 것으로 예상. 모니터링 후 조정.</td>
  </tr>
  <tr>
    <td>4</td>
    <td><strong>T2: RLS 정책</strong> — knowledge_usage 테이블에 RLS 미설정 시 anon 접근 가능</td>
    <td>Low</td>
    <td>service_role로만 INSERT하므로 RLS enable + 정책 없이도 동작. 하지만 명시적으로 <code>ALTER TABLE knowledge_usage ENABLE ROW LEVEL SECURITY;</code> 추가 권장.</td>
  </tr>
</table>

<h3>실행 순서 권장</h3>
<ol>
  <li><strong>T2 먼저</strong> — DB 테이블 생성 + knowledge.ts 로깅 (10분)</li>
  <li><strong>T1</strong> — ai-edit-panel.tsx 신규 + contents.ts 액션 + page.tsx 통합 (1~2시간)</li>
  <li><strong>통합 테스트</strong> — AI 수정 요청 시 knowledge_usage에 로그 확인</li>
</ol>

</body>
</html>
